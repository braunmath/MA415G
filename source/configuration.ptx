<section xml:id="sec-configuration">
    <title>The Configuration Model for Random Networks</title>

<p>
    The first challenge when attempting to identify communities in a network is to define what a "community" within the network actually is.
    One intuitive definition is that a community is a group of nodes that are more densely connected to each other than to the rest of the network.
    However, this definition is somewhat vague, as it does not specify how dense the connections within the community should be, nor does it clarify what it means to be "more densely connected" to each other than to the rest of the network.
</p>
<p>
    Another idea, which is the basis for modularity, is that a community is a set of vertices that have more internal connections than would be expected in a "similar" random network.
    Thus, for example, if we had a network and we wanted to see if it naturally split into two communities, we could consider all possible ways to partition the vertices into two groups and, for each partition, determine how far the number of edges within the two groups are above what would be expected in a "similar" random network.
    Then, the partition that maximizes this distance above the expected value would be considered the "best" division of the network into two communities. 
</p>

<p>
    The first problem that we therefore have to solve is to identify a class of networks that are "similar" to the network under consideration, and then to determine how to compute the expected number of edges within a subset of vertices in such a network.
    This means that we need to do three things:
    <ol>
        <li>
            <p>
                identify a random graph model that matches some of the properties of the graph under consideration,
            </p>
        </li>
        <li>
            <p>
                assign a probability distribution to this model, and finally
            </p>
        </li>
        <li>
            <p>
                compute the expected number of edges within a subset of vertices for these networks.
            </p>
        </li>
    </ol>
</p>

<p>
    We will be able to achieve these goals by using the <em>configuration model</em> as our random graph model.
    The configuration model uses a broader class of networks than only the finite simple graphs we have been exploring so far.
    Instead, it involves the class of looped multigraphs with a given degree sequence.
</p>

<definition xml:id="def-loopedmultigraph">
    <statement>
        <p>
            A <em>looped multigraph</em> is a graph that is allowed to have multiple edges between the same pair of vertices as well as edges that connect a vertex to itself, i.e., loops.
            The <em>degree</em> of a vertex in a looped multigraph is defined as the number of edges incident to that vertex, with loops contributing two to the degree count.
        </p>
    </statement>
</definition>

<example>
    <p>
        Consider the following looped multigraph on ten vertices where every vertex has degree seven.
    </p>
    <figure xml:id="fig-loopedmultigraph">
    <caption>A looped multigraph.</caption>
    <image source="loopedmultigraph.png" width="75%">
    </image>
</figure>
</example>

<p>
    The configuration model is a random graph model that creates a (usually non-uniform) distribution on all looped multigraphs with a fixed degree sequence.
    When thinking about the configuration model, it is often helpful to use the "stub" or "half-edge" representation of a looped multigraph.
    In this representation, each vertex <m>i</m> is assigned <m>d_i</m> "stubs", or partial edges incident to <m>i</m>, and the looped multigraph is formed by randomly pairing these stubs to create edges.
    Thus, every looped multigraph in the configuration model is generated by a perfect matching of the set of all stubs.
</p>

<exercise>
    <p>
        Consider the looped multigraph in the figure below, which is the same as we considered in the previous example.
        <ol>
            <li>
                <p>
                    Imagine cutting each edge in half to create stubs.
                    How many stubs are there in total? (Remember that every vertex has degree seven.)
                </p>
            </li>
            <li>
                <p>
                    If you cut each of the loops and reconnect the resulting stubs to form edges, can you create a different multigraph with the same degree sequence that has no loops?
                </p>
            </li>
        </ol>
    </p>
<figure xml:id="fig-loopedmultigraph1">
    <caption>A looped multigraph.</caption>
    <image source="loopedmultigraph.png" width="75%">
    </image>
</figure>
</exercise>

<definition xml:id="def-configurationmodel">
    <statement>
        <p>
            Fix a sequence of non-negative integers <m>(d_1, d_2, \ldots, d_n)</m> such that the sum <m>d_1 + d_2 + \cdots + d_n</m> is even.
            The <em>configuration model</em> with degree sequence <m>(d_1, d_2, \ldots, d_n)</m> is the probability space where:
            <ul>
                <li>
                    <p>
                        the event set consists of all perfect matchings of the set of stubs formed on the vertex set <m>\{1,2,\ldots,n\}</m> where vertex <m>i</m> has <m>d_i</m> stubs, and
                    </p>
                </li>
                <li>
                    <p>
                        the uniform distribution is used for the set of these perfect matchings of stubs.
                    </p>
                </li>
            </ul> 
            Each such perfect matching of stubs corresponds to a looped multigraph on vertex set <m>\{1, 2, \ldots, n\}</m> where vertex <m>i</m> has degree <m>d_i</m>.
            Thus, the configuration model induces a probability distribution on the set of looped multigraphs with degree sequence <m>(d_1, d_2, \ldots, d_n)</m>.
        </p>
    </statement>
</definition>

<p>
    Note that it is possible for two different perfect matchings of stubs to correspond to the same looped multigraph.
    Thus the configuration model is <em>not</em> the uniform distribution on looped multigraphs with the given degree sequence, rather it is the uniform distribution on perfect matchings of stubs, and this induces a non-uniform probability distribution on the looped multigraphs.
    The following example illustrates this point.
</p>

<example>
    <p>
        Consider the configuration model on two vertices with degree sequence <m>(2,2)</m>.
        Let's denote the two vertices as <m>u</m> and <m>v</m>.
        Each vertex has two stubs, so we have a total of four stubs: <m>u_1, u_2</m> for vertex <m>u</m> and <m>v_1, v_2</m> for vertex <m>v</m>.
        The possible perfect matchings of these stubs are:
        <ul>
            <li>
                <p>
                    <m>\{(u_1, v_1), (u_2, v_2)\}</m>
                </p>
            </li>
            <li>
                <p>
                    <m>\{(u_1, v_2), (u_2, v_1)\}</m>
                </p>
            </li>
            <li>
                <p>
                    <m>\{(u_1, u_2), (v_1, v_2)\}</m>
                </p>
            </li>
        </ul>
        The first two matchings correspond to the same simple graph with two edges between <m>u</m> and <m>v</m>, while the third matching corresponds to a graph with two loops, one on each vertex.
        Therefore, in the configuration model with degree sequence <m>(2,2)</m>, the network with two edges between <m>u</m> and <m>v</m> has a probability of <m>2/3</m>, while the network with two loops has a probability of <m>1/3</m>.
    </p>
    <p>
        Let's check this experimentally: using Sagemath with the python networkx library, we can simulate the configuration model with degree sequence <m>(2,2)</m> multiple times and observe the frequencies of the resulting graphs.
        Here is a sample code snippet to perform this simulation where we randomly sample from the configuration model 10000 times.
    </p>
        <program language="python">
import networkx as nx

D = {}

# Simulate the configuration model 10000 times
for _ in range(10000):
    G = Graph(nx.configuration_model([2,2])).copy(immutable=True)
    if G in D.keys():
        D[G] += 1
    else:
        D[G] = 1

# Display the results
for g in D.keys():
    print(D[g])
    show(g)
    print()

L = [D[g] for g in D.keys()]
s = sum(L)
for i in L:
    print(N(i/s))
        </program>
    <p>
        You can copy and paste this code into <url href="https://sagecell.sagemath.org/" /> to test it yourself, and you will see that the results align with our theoretical calculations -- the graph with two parallel edges appears approximately twice as often as the graph with two loops.
    </p>
</example>

<exercise>
    <p>
        <ol>
            <li>
                <p>
                    What is the event set for the configuration model with degree sequence <m>(1,2,3)</m> on three vertices? (Hint: there are fifteen perfect matchings, hence fifteen events.)
                </p>
            </li>
            <li>
                <p>
                    What is the probability of each looped multigraph in this configuration model? (Hint: there are three looped multigraphs with degree sequence <m>(1,2,3)</m>.)
                </p>
            </li>
            <li>
                <p>
                    Modify the Sagemath code snippet in the previous example to simulate the configuration model with degree sequence <m>(1,2,3)</m> and verify your answer to question 2 experimentally.
                </p>
            </li>
        </ol>
    </p>
</exercise>

<p>
   We can compute the total number of perfect matchings of the stubs in the configuration model with degree sequence <m>(d_1, d_2, \ldots, d_n)</m>.
</p>

<proposition xml:id="prop-stubmatchingcount">
    <statement>
        <p>
            Let <m>(d_1, d_2, \ldots, d_n)</m> be a sequence of non-negative integers such that <m>2m = d_1 + d_2 + \cdots + d_n</m> is even, where <m>m=|E|</m> is the number of edges in any looped multigraph with degree sequence <m>(d_1, d_2, \ldots, d_n)</m>.
            The total number of perfect matchings of the set of <m>2m</m> stubs in the configuration model with degree sequence <m>(d_1, d_2, \ldots, d_n)</m> is given by
            <me>
                \frac{(2m)!}{2^{m} (m)!} = (2m - 1)!!
            </me>
            where <m>(2m - 1)!!</m> denotes the double factorial of <m>2m - 1</m>, defined as the product of all odd integers from <m>1</m> to <m>2m - 1</m>.
        </p>
    </statement>
</proposition>

<proof>
    <p>
        List the pairs in the perfect matching one at a time.
        There are <m>2m</m> choices for the first stub in the first pair and <m>2m - 1</m> choices for the second stub in the first pair.
        After choosing the first pair, there are <m>2m - 2</m> stubs left, so there are <m>2m - 2</m> choices for the first stub in the second pair and <m>2m - 3</m> choices for the second stub in the second pair.
        Continuing in this way, we see that the total number of ways to list the pairs is
        <me>
            (2m) \cdot (2m - 1) \cdot (2m - 2) \cdot (2m - 3) \cdots 3 \cdot 2 \cdot 1 = (2m)!
        </me>
        However, in this count, each perfect matching is counted multiple times.
        Specifically, each perfect matching is counted <m>2^{m} \cdot (m)!</m> times, since:
        <ul>
            <li>
                <p>
                    each of the <m>m</m> pairs can be listed in two different orders, and
                </p>
            </li>
            <li>
                <p>
                    the <m>m</m> pairs themselves can be listed in any order.
                </p>
            </li>
        </ul>
        Therefore, the total number of distinct perfect matchings is
        <me>
            \frac{(2m)!}{2^{m} (m)!}\, .
        </me>
        Some additional algebraic manipulation shows that this expression is equal to <m>(2m - 1)!!</m>.
    </p>
</proof>

<exercise>
    <p>
        Discuss the proof above. Does it make sense? Why or why not?
    </p>
</exercise>

<p>
    We next use this fact to determine the expected number of edges between two vertices in this model.
</p>

<theorem xml:id="thm-expectededgesconfiguration">
    <statement>
        <p>
            Let <m>(d_1, d_2, \ldots, d_n)</m> be a sequence of non-negative integers such that <m>2m = d_1 + d_2 + \cdots + d_n</m>.
            In the configuration model with degree sequence <m>(d_1, d_2, \ldots, d_n)</m>, the expected number of edges between vertices <m>i</m> and <m>j</m> is given by
            <me>
                \frac{d_i d_j}{2m - 1}\, . 
            </me>
        </p>
    </statement>
</theorem>

<proof>
    <p>
        We will use indicator functions to compute the expected number of edges between vertices <m>i</m> and <m>j</m>.
        Let <m>X</m> be the random variable that counts the number of edges between vertices <m>i</m> and <m>j</m>.
        We can express <m>X</m> as the sum of indicator functions:
        <me>
            X = \sum_{a=1}^{d_i} \sum_{b=1}^{d_j} X_{a,b}
        </me>
        where <m>X_{a,b}</m> is the indicator function that is <m>1</m> if the <m>a</m>-th stub of vertex <m>i</m> is matched with the <m>b</m>-th stub of vertex <m>j</m>, and <m>0</m> otherwise.
        By the linearity of expectation, we have:
        <me>
            \mathbb{E}[X] = \mathbb{E}\left[\sum_{a=1}^{d_i} \sum_{b=1}^{d_j} X_{a,b}\right] = \sum_{a=1}^{d_i} \sum_{b=1}^{d_j} \mathbb{E}[X_{a,b}]\, .
        </me>
        Since <m>X_{a,b}</m> is an indicator function, its expectation is equal to the probability that the <m>a</m>-th stub of vertex <m>i</m> is matched with the <m>b</m>-th stub of vertex <m>j</m>.
        The number of perfect matchings where these two stubs are matched together is equal to the total number of perfect matchings of the remaining <m>2m - 2</m> stubs.
        By our preceding result, this number is <m>(2m - 3)!!</m>.
        The total number of perfect matchings of all <m>2m</m> stubs is <m>(2m - 1)!!</m>.
        Thus, the probability that the <m>a</m>-th stub of vertex <m>i</m> is matched with the <m>b</m>-th stub of vertex <m>j</m> is:
        <me>
            \mathbb{P}(X_{a,b} = 1) = \frac{(2m - 3)!!}{(2m - 1)!!} = \frac{1}{2m - 1}\, .
        </me>
        Substituting this back into our expression for the expectation, we get:
        <me>
            \mathbb{E}[X] = \sum_{a=1}^{d_i} \sum_{b=1}^{d_j} \frac{1}{2m - 1} = \frac{d_i d_j}{2m - 1}\, .
        </me>
    </p>
</proof>

<exercise>
    <p>
        Discuss the proof above. Does it make sense? Why or why not?
    </p>
</exercise>

<p>
    We have now achieved all three of our goals for developing the configuration model and computing the expected number of edges between a pair of vertices.
    Our task in the next section will be to use the expected number of edges computed above to define the modularity of a partition of a network.
</p>

</section>